import type { SeverityLevel } from "@shared/schema";

export interface ParsedVulnerability {
  name: string;
  severity: SeverityLevel;
  cve?: string;
  cwe?: string;
  cvss?: string;
  description?: string;
  solution?: string;
  references?: string[];
  scanner: string;
  templateId?: string;
  matchedAt?: string;
  extractedData?: Record<string, unknown>;
  proof?: string;
  host?: string;
  port?: number;
  protocol?: string;
}

export interface ParsedVulnerabilityResult {
  scanner: string;
  vulnerabilities: ParsedVulnerability[];
  rawOutput: string;
}

const ANSI_PATTERN = /\u001b\[[0-9;]*m/g;

function stripAnsi(value: string): string {
  return value.replace(ANSI_PATTERN, "");
}

export function parseNucleiVulnerabilities(output: string): ParsedVulnerabilityResult {
  const result: ParsedVulnerabilityResult = {
    scanner: "nuclei",
    vulnerabilities: [],
    rawOutput: output,
  };

  const lines = output.split("\n");

  for (const line of lines) {
    const trimmed = stripAnsi(line).trim();
    if (!trimmed) continue;

    if (trimmed.startsWith("{")) {
      try {
        const json = JSON.parse(trimmed);
        const vuln = parseNucleiJsonLine(json);
        if (vuln) {
          result.vulnerabilities.push(vuln);
        }
      } catch {
      }
      continue;
    }

    const textVuln = parseNucleiTextLine(trimmed);
    if (textVuln) {
      result.vulnerabilities.push(textVuln);
    }
  }

  return result;
}

function parseNucleiJsonLine(json: Record<string, unknown>): ParsedVulnerability | null {
  const info = json.info as Record<string, unknown> | undefined;
  if (!info) return null;

  const name = (info.name as string) || (json["template-id"] as string) || "Unknown";
  const rawSeverity = ((info.severity as string) || "info").toLowerCase();
  const severity = normalizeSeverity(rawSeverity);

  const classification = info.classification as Record<string, unknown> | undefined;
  let cve: string | undefined;
  let cwe: string | undefined;
  let cvss: string | undefined;

  if (classification) {
    const cveIds = classification["cve-id"] as string[] | string | undefined;
    if (Array.isArray(cveIds) && cveIds.length > 0) {
      cve = cveIds[0];
    } else if (typeof cveIds === "string") {
      cve = cveIds;
    }

    const cweIds = classification["cwe-id"] as string[] | string | undefined;
    if (Array.isArray(cweIds) && cweIds.length > 0) {
      cwe = cweIds[0];
    } else if (typeof cweIds === "string") {
      cwe = cweIds;
    }

    const cvssMetrics = classification["cvss-metrics"] as string | undefined;
    const cvssScore = classification["cvss-score"] as number | undefined;
    if (cvssScore !== undefined) {
      cvss = cvssScore.toString();
    } else if (cvssMetrics) {
      const scoreMatch = cvssMetrics.match(/(\d+\.?\d*)/);
      if (scoreMatch) {
        cvss = scoreMatch[1];
      }
    }
  }

  const description = (info.description as string) || undefined;
  const solution = (info.remediation as string) || (info.solution as string) || undefined;

  let references: string[] | undefined;
  const refArray = info.reference as string[] | undefined;
  if (Array.isArray(refArray) && refArray.length > 0) {
    references = refArray;
  }

  const templateId = (json["template-id"] as string) || undefined;

  let matchedAt: string | undefined;
  const host = json.host as string | undefined;
  const matched = json["matched-at"] as string | undefined;
  matchedAt = matched || host;

  let hostIp: string | undefined;
  let port: number | undefined;
  let protocol: string | undefined;

  if (matchedAt) {
    const urlMatch = matchedAt.match(/(https?):\/\/([^/:]+)(?::(\d+))?/);
    if (urlMatch) {
      protocol = urlMatch[1];
      hostIp = urlMatch[2];
      port = urlMatch[3] ? parseInt(urlMatch[3], 10) : (protocol === "https" ? 443 : 80);
    } else {
      const ipPortMatch = matchedAt.match(/(\d+\.\d+\.\d+\.\d+)(?::(\d+))?/);
      if (ipPortMatch) {
        hostIp = ipPortMatch[1];
        port = ipPortMatch[2] ? parseInt(ipPortMatch[2], 10) : undefined;
      } else {
        hostIp = matchedAt.replace(/https?:\/\//, "").split(/[/:]/)[0];
      }
    }
  }

  const extractedData: Record<string, unknown> = {};
  if (json["extracted-results"]) {
    extractedData.extractedResults = json["extracted-results"];
  }
  if (json["matcher-name"]) {
    extractedData.matcherName = json["matcher-name"];
  }
  if (json.curl) {
    extractedData.curl = json.curl;
  }

  const proof = json["matched-at"] as string | undefined;

  return {
    name,
    severity,
    cve,
    cwe,
    cvss,
    description,
    solution,
    references,
    scanner: "nuclei",
    templateId,
    matchedAt,
    extractedData: Object.keys(extractedData).length > 0 ? extractedData : undefined,
    proof,
    host: hostIp,
    port,
    protocol,
  };
}

function parseNucleiTextLine(line: string): ParsedVulnerability | null {
  const match = line.match(/\[([^\]]+)\]\s*\[([^\]]+)\]\s*(?:\[([^\]]+)\])?\s*(https?:\/\/)?([^\s]+)/);
  if (!match) return null;

  const [, templateId, bracket2, bracket3, protocol, target] = match;
  const severitySource = (bracket3 || bracket2 || "info").toLowerCase();
  const severity = normalizeSeverity(severitySource);

  let hostIp: string | undefined;
  let port: number | undefined;
  let matchedAt = (protocol || "") + target;

  const urlMatch = target.match(/([^/:]+)(?::(\d+))?/);
  if (urlMatch) {
    hostIp = urlMatch[1];
    port = urlMatch[2] ? parseInt(urlMatch[2], 10) : (protocol === "https://" ? 443 : 80);
  }

  const cveMatch = templateId.match(/CVE-\d{4}-\d+/i);
  const cve = cveMatch ? cveMatch[0].toUpperCase() : undefined;

  return {
    name: templateId.replace(/-/g, " ").replace(/\b\w/g, c => c.toUpperCase()),
    severity,
    cve,
    scanner: "nuclei",
    templateId,
    matchedAt,
    host: hostIp,
    port,
    protocol: protocol?.replace("://", "") || "http",
  };
}

function normalizeSeverity(raw: string): SeverityLevel {
  const lower = raw.toLowerCase();
  if (lower === "critical") return "critical";
  if (lower === "high") return "high";
  if (lower === "medium") return "medium";
  if (lower === "low") return "low";
  return "info";
}

export async function enrichVulnerabilityFromNVD(cve: string): Promise<{
  description?: string;
  cvss?: string;
  cwe?: string;
  references?: string[];
} | null> {
  if (!cve || !cve.match(/^CVE-\d{4}-\d+$/i)) {
    return null;
  }

  try {
    const response = await fetch(
      `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cve.toUpperCase()}`,
      {
        headers: {
          "User-Agent": "PenTest-Framework/1.0",
        },
      }
    );

    if (!response.ok) {
      console.log(`NVD API returned ${response.status} for ${cve}`);
      return null;
    }

    const data = await response.json() as { vulnerabilities?: Array<{ cve: Record<string, unknown> }> };

    if (!data.vulnerabilities || data.vulnerabilities.length === 0) {
      return null;
    }

    const cveData = data.vulnerabilities[0].cve;
    const result: {
      description?: string;
      cvss?: string;
      cwe?: string;
      references?: string[];
    } = {};

    const descriptions = cveData.descriptions as Array<{ lang: string; value: string }> | undefined;
    if (descriptions) {
      const enDesc = descriptions.find(d => d.lang === "en");
      if (enDesc) {
        result.description = enDesc.value;
      }
    }

    const metrics = cveData.metrics as Record<string, unknown> | undefined;
    if (metrics) {
      const cvssV31 = metrics.cvssMetricV31 as Array<{ cvssData: { baseScore: number } }> | undefined;
      const cvssV30 = metrics.cvssMetricV30 as Array<{ cvssData: { baseScore: number } }> | undefined;
      const cvssV2 = metrics.cvssMetricV2 as Array<{ cvssData: { baseScore: number } }> | undefined;

      if (cvssV31 && cvssV31.length > 0) {
        result.cvss = cvssV31[0].cvssData.baseScore.toString();
      } else if (cvssV30 && cvssV30.length > 0) {
        result.cvss = cvssV30[0].cvssData.baseScore.toString();
      } else if (cvssV2 && cvssV2.length > 0) {
        result.cvss = cvssV2[0].cvssData.baseScore.toString();
      }
    }

    const weaknesses = cveData.weaknesses as Array<{ description: Array<{ lang: string; value: string }> }> | undefined;
    if (weaknesses && weaknesses.length > 0) {
      const cweDesc = weaknesses[0].description.find(d => d.value.startsWith("CWE-"));
      if (cweDesc) {
        result.cwe = cweDesc.value;
      }
    }

    const refs = cveData.references as Array<{ url: string }> | undefined;
    if (refs && refs.length > 0) {
      result.references = refs.slice(0, 5).map(r => r.url);
    }

    return result;
  } catch (error) {
    console.error(`Error fetching NVD data for ${cve}:`, error);
    return null;
  }
}

export async function enrichVulnerabilities(
  vulnerabilities: ParsedVulnerability[]
): Promise<ParsedVulnerability[]> {
  const enrichedVulns: ParsedVulnerability[] = [];

  for (const vuln of vulnerabilities) {
    const enrichedVuln = { ...vuln };

    if (vuln.cve) {
      const nvdData = await enrichVulnerabilityFromNVD(vuln.cve);
      if (nvdData) {
        if (nvdData.description && !enrichedVuln.description) {
          enrichedVuln.description = nvdData.description;
        }
        if (nvdData.cvss && !enrichedVuln.cvss) {
          enrichedVuln.cvss = nvdData.cvss;
        }
        if (nvdData.cwe && !enrichedVuln.cwe) {
          enrichedVuln.cwe = nvdData.cwe;
        }
        if (nvdData.references && (!enrichedVuln.references || enrichedVuln.references.length === 0)) {
          enrichedVuln.references = nvdData.references;
        }
      }
    }

    enrichedVulns.push(enrichedVuln);
  }

  return enrichedVulns;
}

export function detectVulnerabilityScanner(output: string): string | null {
  const cleaned = stripAnsi(output);
  const lower = cleaned.toLowerCase();
  const trimmed = cleaned.trim();

  if (trimmed.startsWith("{") && trimmed.includes('"template-id"')) {
    return "nuclei";
  }

  if (
    lower.includes("[nuclei]") ||
    /\[[a-z-]+\]\s*\[(info|low|medium|high|critical)\]/i.test(trimmed) ||
    /\[[^\]]+\]\s*\[[^\]]+\]\s*\[(info|low|medium|high|critical)\]/i.test(trimmed) ||
    /\[[^\]]+\]\s*\[[^\]]+\]\s*\[(info|low|medium|high|critical)\]/i.test(cleaned)
  ) {
    return "nuclei";
  }

  if (lower.includes("nikto") && lower.includes("vulnerability")) {
    return "nikto";
  }

  if (lower.includes("testssl") && (lower.includes("vulnerable") || lower.includes("cve"))) {
    return "testssl";
  }

  return null;
}

export function parseVulnerabilityScan(output: string): ParsedVulnerabilityResult {
  const scanner = detectVulnerabilityScanner(output);

  if (scanner === "nuclei") {
    return parseNucleiVulnerabilities(output);
  }

  return {
    scanner: scanner || "unknown",
    vulnerabilities: [],
    rawOutput: output,
  };
}
